To check if WinActor has finished running from your VB.NET application, you can use the Process.WaitForExit() method. This allows your app to:

‚úÖ Start WinActor
‚è≥ Wait while the scenario runs
‚úÖ Resume execution after WinActor closes


---

‚úÖ Updated VB.NET Code Example

Imports System.Diagnostics

Public Class Form1

    Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click
        Dim winActorPath As String = "C:\Program Files (x86)\WinActor\WinActor.exe" ' Adjust if different
        Dim scenarioPath As String = "D:\Scenarios\MyScenario.ums5" ' Adjust your .ums5 file path

        If IO.File.Exists(winActorPath) AndAlso IO.File.Exists(scenarioPath) Then
            Try
                Dim proc As New Process()
                proc.StartInfo.FileName = winActorPath
                proc.StartInfo.Arguments = """" & scenarioPath & """"
                proc.Start()

                ' Wait for WinActor process to exit
                proc.WaitForExit()

                ' After WinActor finishes
                MessageBox.Show("WinActor scenario completed.", "Done", MessageBoxButtons.OK, MessageBoxIcon.Information)

            Catch ex As Exception
                MessageBox.Show("Error: " & ex.Message)
            End Try
        Else
            MessageBox.Show("WinActor or scenario file not found.")
        End If
    End Sub

End Class


---

üîç What WaitForExit() Does

The app pauses until the WinActor process exits.

Once WinActor closes, your VB.NET app continues (e.g., shows a message or performs next steps).



---

‚è± Optional: Add a Timeout

If you want to prevent freezing forever, you can wait for a maximum number of milliseconds:

If proc.WaitForExit(60000) Then ' Waits up to 60 seconds
    MessageBox.Show("WinActor finished within 60 seconds.")
Else
    MessageBox.Show("Timeout: WinActor is still running.")
End If


---

Let me know if you want to:

Run WinActor in silent mode

Read output from the scenario

Or launch multiple scenarios in sequence

Update 08/09/25 06:32AM

Alright ‚Äî I‚Äôll add an optimization so if WinActor already has the chosen .ums scenario open, the code will skip the File ‚Üí Open dialog and just click Run.

This will make re-running much faster because it won‚Äôt reload the scenario unnecessarily.


---

Optimized VB.NET Code ‚Äì Two Scenario Buttons

Imports System.Diagnostics
Imports System.Windows.Automation
Imports System.Runtime.InteropServices

Public Class Form1

    <DllImport("user32.dll")>
    Private Shared Function SetForegroundWindow(hWnd As IntPtr) As Boolean
    End Function

    ' Path to WinActor executable
    Private winActorPath As String = "C:\Program Files\WinActor\WinActor.exe"

    ' Two scenarios
    Private scenario1Path As String = "C:\Scenarios\Scenario1.ums"
    Private scenario2Path As String = "C:\Scenarios\Scenario2.ums"

    Private Sub btnScenario1_Click(sender As Object, e As EventArgs) Handles btnScenario1.Click
        RunWinActorScenario(scenario1Path)
    End Sub

    Private Sub btnScenario2_Click(sender As Object, e As EventArgs) Handles btnScenario2.Click
        RunWinActorScenario(scenario2Path)
    End Sub

    Private Sub RunWinActorScenario(scenarioPath As String)
        Try
            Dim processName As String = "WinActor"
            Dim existingProcesses = Process.GetProcessesByName(processName)

            If existingProcesses.Length = 0 Then
                ' WinActor not running ‚Üí launch and run
                Dim startInfo As New ProcessStartInfo()
                startInfo.FileName = winActorPath
                startInfo.Arguments = $"-f ""{scenarioPath}"" -a"
                Process.Start(startInfo)
                Return
            End If

            ' WinActor is running ‚Üí bring to front
            Dim proc = existingProcesses(0)
            SetForegroundWindow(proc.MainWindowHandle)

            ' Attach UI Automation
            Dim rootElement As AutomationElement = AutomationElement.FromHandle(proc.MainWindowHandle)
            If rootElement Is Nothing Then
                MessageBox.Show("Cannot attach to WinActor UI.")
                Return
            End If

            ' --- Optimization: Check if current scenario is already open ---
            Dim windowTitle As String = proc.MainWindowTitle
            If windowTitle.EndsWith(IO.Path.GetFileName(scenarioPath), StringComparison.OrdinalIgnoreCase) Then
                ' Scenario already open ‚Üí just click Run
                Dim runButton As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                    New PropertyCondition(AutomationElement.NameProperty, "Run"))
                runButton?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
                Return
            End If

            ' Otherwise ‚Üí load new scenario
            ' Step 1: Click File menu
            Dim fileMenu As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                New PropertyCondition(AutomationElement.NameProperty, "File"))
            fileMenu?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
            Threading.Thread.Sleep(300)

            ' Step 2: Click Open
            Dim openMenu As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                New PropertyCondition(AutomationElement.NameProperty, "Open"))
            openMenu?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
            Threading.Thread.Sleep(500)

            ' Step 3: Handle the Open dialog
            Dim openDialog As AutomationElement = AutomationElement.RootElement.FindFirst(TreeScope.Children,
                New PropertyCondition(AutomationElement.NameProperty, "Open"))
            If openDialog IsNot Nothing Then
                ' File name textbox
                Dim fileNameBox As AutomationElement = openDialog.FindFirst(TreeScope.Descendants,
                    New PropertyCondition(AutomationElement.AutomationIdProperty, "1148"))
                If fileNameBox IsNot Nothing Then
                    Dim valuePattern As ValuePattern = TryCast(fileNameBox.GetCurrentPattern(ValuePattern.Pattern), ValuePattern)
                    valuePattern?.SetValue(scenarioPath)
                    Threading.Thread.Sleep(300)
                End If

                ' Click Open button
                Dim openButton As AutomationElement = openDialog.FindFirst(TreeScope.Descendants,
                    New PropertyCondition(AutomationElement.NameProperty, "Open"))
                openButton?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
            End If

            ' Step 4: Click Run button
            Threading.Thread.Sleep(1500)
            Dim runBtn As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                New PropertyCondition(AutomationElement.NameProperty, "Run"))
            runBtn?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()

        Catch ex As Exception
            MessageBox.Show("Error running WinActor scenario: " & ex.Message)
        End Try
    End Sub

End Class


---

What‚Äôs New in This Version

1. Scenario Already Open Detection

Reads proc.MainWindowTitle.

If the title ends with the file name of your .ums ‚Üí it skips the ‚ÄúOpen‚Äù menu and directly clicks Run.

This makes repeated runs almost instant.



2. Two Button Support

btnScenario1 ‚Üí runs Scenario1.ums.

btnScenario2 ‚Üí runs Scenario2.ums.



3. No unnecessary reloading

Only loads the file if it‚Äôs different from the one currently open.





---

Requirements

You still need UIAutomationClient and UIAutomationTypes references.

Update:

winActorPath ‚Üí path to WinActor.exe.

scenario1Path / scenario2Path ‚Üí your .ums files.


Make sure the ‚ÄúRun‚Äù button‚Äôs name in WinActor is exactly "Run" (or replace in code if it‚Äôs localized).



---

If you want, I can also make it so that if you run Scenario1 while Scenario2 is open, it automatically switches and starts Scenario1 in one click ‚Äî no confirmation boxes, just an immediate swap and run.
That would make it feel like a real "scenario launcher" app.

Do you want me to make that improvement?


****


Alright ‚Äî here‚Äôs the updated two-button VB.NET code that:

Removes the CLI arguments so you won‚Äôt get the "Undefined option" error.

Works even if your WinActor version doesn‚Äôt support command-line scenario launching.

Uses UI Automation to open and run the .ums scenario whether WinActor is already open or just starting.

Has an optimization check so if the scenario is already loaded, it just clicks Run without reloading.



---

VB.NET Code ‚Äì Two Buttons, No CLI Arguments

Imports System.Diagnostics
Imports System.Windows.Automation
Imports System.Runtime.InteropServices

Public Class Form1

    <DllImport("user32.dll")>
    Private Shared Function SetForegroundWindow(hWnd As IntPtr) As Boolean
    End Function

    ' Path to WinActor executable
    Private winActorPath As String = "C:\Program Files\WinActor\WinActor.exe"

    ' Paths to two scenarios
    Private scenario1Path As String = "C:\Scenarios\Scenario1.ums"
    Private scenario2Path As String = "C:\Scenarios\Scenario2.ums"

    Private Sub btnScenario1_Click(sender As Object, e As EventArgs) Handles btnScenario1.Click
        RunWinActorScenario(scenario1Path)
    End Sub

    Private Sub btnScenario2_Click(sender As Object, e As EventArgs) Handles btnScenario2.Click
        RunWinActorScenario(scenario2Path)
    End Sub

    Private Sub RunWinActorScenario(scenarioPath As String)
        Try
            Dim processName As String = "WinActor"
            Dim existingProcesses = Process.GetProcessesByName(processName)
            Dim proc As Process

            If existingProcesses.Length = 0 Then
                ' WinActor not running ‚Üí start without arguments
                proc = Process.Start(winActorPath)

                ' Wait for the UI to load before automating
                Threading.Thread.Sleep(5000) ' adjust if your WinActor loads slower
            Else
                proc = existingProcesses(0)
                SetForegroundWindow(proc.MainWindowHandle)
            End If

            ' Attach to WinActor UI
            Dim rootElement As AutomationElement = AutomationElement.FromHandle(proc.MainWindowHandle)
            If rootElement Is Nothing Then
                MessageBox.Show("Cannot attach to WinActor UI.")
                Return
            End If

            ' --- Optimization: Skip loading if scenario is already open ---
            Dim windowTitle As String = proc.MainWindowTitle
            If windowTitle.EndsWith(IO.Path.GetFileName(scenarioPath), StringComparison.OrdinalIgnoreCase) Then
                ' Already open ‚Üí just click Run
                Dim runButton As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                    New PropertyCondition(AutomationElement.NameProperty, "Run"))
                runButton?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
                Return
            End If

            ' Step 1: Click File menu
            Dim fileMenu As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                New PropertyCondition(AutomationElement.NameProperty, "File"))
            fileMenu?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
            Threading.Thread.Sleep(300)

            ' Step 2: Click Open
            Dim openMenu As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                New PropertyCondition(AutomationElement.NameProperty, "Open"))
            openMenu?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
            Threading.Thread.Sleep(500)

            ' Step 3: Handle the Open dialog
            Dim openDialog As AutomationElement = AutomationElement.RootElement.FindFirst(TreeScope.Children,
                New PropertyCondition(AutomationElement.NameProperty, "Open"))
            If openDialog IsNot Nothing Then
                ' File name textbox
                Dim fileNameBox As AutomationElement = openDialog.FindFirst(TreeScope.Descendants,
                    New PropertyCondition(AutomationElement.AutomationIdProperty, "1148"))
                If fileNameBox IsNot Nothing Then
                    Dim valuePattern As ValuePattern = TryCast(fileNameBox.GetCurrentPattern(ValuePattern.Pattern), ValuePattern)
                    valuePattern?.SetValue(scenarioPath)
                    Threading.Thread.Sleep(300)
                End If

                ' Click Open button
                Dim openButton As AutomationElement = openDialog.FindFirst(TreeScope.Descendants,
                    New PropertyCondition(AutomationElement.NameProperty, "Open"))
                openButton?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()
            End If

            ' Step 4: Click Run button
            Threading.Thread.Sleep(1500)
            Dim runBtn As AutomationElement = rootElement.FindFirst(TreeScope.Descendants,
                New PropertyCondition(AutomationElement.NameProperty, "Run"))
            runBtn?.GetCurrentPattern(InvokePattern.Pattern)?.Invoke()

        Catch ex As Exception
            MessageBox.Show("Error running WinActor scenario: " & ex.Message)
        End Try
    End Sub

End Class


---

What Changed

Removed the -f and -a arguments to avoid "Undefined option" errors.

Always starts WinActor with no arguments on first run, then uses UI Automation to load and run the scenario.

Optimization check:

If proc.MainWindowTitle already matches the .ums file name, it skips loading and just clicks Run.


Works for two buttons so you can launch two different scenarios.



---

Setup

1. Add two buttons to your VB.NET form: btnScenario1 and btnScenario2.


2. Update:

winActorPath ‚Üí your WinActor.exe location.

scenario1Path / scenario2Path ‚Üí your .ums files.



3. Add references in Visual Studio:

UIAutomationClient

UIAutomationTypes





---

If you want, I can extend this so that if you switch scenarios (e.g., from Scenario1 to Scenario2), it automatically replaces the loaded one and runs immediately, no confirmation box.
That would make your launcher switch scenarios in one click.

Do you want me to add that auto-switch behavior next?




****

Gotcha ‚Äî that

hwnd cannot be intptr.zero or null

error means our UI Automation code couldn‚Äôt find the WinActor window at the moment we tried to automate it, so it got a null handle (IntPtr.Zero) instead of a valid one.

That usually happens because:

WinActor takes longer to load than our wait time (Thread.Sleep(5000))

Or the window title we are looking for doesn‚Äôt match exactly

Or WinActor has a splash screen before the main window appears



---

Fix: Make it wait until WinActor‚Äôs main window is ready

Instead of hardcoding Thread.Sleep(5000), we can loop until the WinActor window is found, with a timeout.

Here‚Äôs the updated RunWinActorScenario with safe waiting:

Imports System.Diagnostics
Imports System.Threading
Imports System.Windows.Automation

Public Class Form1

    Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click
        RunWinActorScenario("C:\Path\To\Scenario1.ums")
    End Sub

    Private Sub Button2_Click(sender As Object, e As EventArgs) Handles Button2.Click
        RunWinActorScenario("C:\Path\To\Scenario2.ums")
    End Sub

    Private Sub RunWinActorScenario(scenarioPath As String)
        Dim winActorPath As String = "C:\Program Files\WinActor\WinActor.exe"
        Dim winActorTitle As String = "WinActor" ' Adjust if your main window has extra text

        Dim existingProcesses = Process.GetProcessesByName("WinActor")
        If existingProcesses.Length = 0 Then
            ' Start WinActor without arguments
            Process.Start(winActorPath)
        End If

        ' Wait until the main window is found (max 30 seconds)
        Dim mainWindow As Process = Nothing
        Dim sw As Stopwatch = Stopwatch.StartNew()

        Do
            existingProcesses = Process.GetProcessesByName("WinActor")
            If existingProcesses.Length > 0 AndAlso existingProcesses(0).MainWindowHandle <> IntPtr.Zero Then
                mainWindow = existingProcesses(0)
                Exit Do
            End If
            Thread.Sleep(500)
        Loop While sw.ElapsedMilliseconds < 30000

        If mainWindow Is Nothing Then
            MessageBox.Show("WinActor main window not found. Please check if the app launched correctly.")
            Exit Sub
        End If

        ' Automate: open the scenario file
        Dim winElement As AutomationElement = AutomationElement.FromHandle(mainWindow.MainWindowHandle)
        If winElement Is Nothing Then
            MessageBox.Show("Could not access WinActor UI for automation.")
            Exit Sub
        End If

        ' Example: send Ctrl+O to open file
        My.Computer.Keyboard.SendKeys("^{O}")
        Thread.Sleep(500)

        ' Type the scenario path
        My.Computer.Keyboard.SendKeys("""" & scenarioPath & """")
        Thread.Sleep(500)
        My.Computer.Keyboard.SendKeys("{ENTER}")
        Thread.Sleep(1000)

        ' Run the scenario (F5 or menu command)
        My.Computer.Keyboard.SendKeys("{F5}")
    End Sub

End Class


---

Changes from before:

Wait loop until MainWindowHandle is valid (instead of fixed 5s wait) ‚Üí fixes the IntPtr.Zero error.

Timeout of 30 seconds ‚Üí prevents infinite waiting if something‚Äôs wrong.

Still works with two buttons for two scenarios.



---

If you want, I can add an optimization check so that:

If WinActor is already running with the same scenario open, it just re-runs without reloading the file.

If another scenario is open, it loads the new one.


That way, it‚Äôs even faster and avoids unnecessary reloads.

Do you want me to add that scenario-check optimization next?


***


Gotcha ‚Äî you want the VB.NET form to wait until the WinActor scenario finishes running,
then show a MessageBox saying it‚Äôs finished.


---

Since WinActor doesn‚Äôt have a built-in ‚Äúexecution finished‚Äù event we can hook into,
we can simulate it by monitoring the WinActor main window title:

While a scenario is running, WinActor‚Äôs title usually contains something like [Running] or the execution icon changes.

When execution ends, the title goes back to just the scenario name.


We can poll this in a background loop until it changes back, then show a confirmation.


---

Updated OpenScenario With Execution Finish Message

Private Sub OpenScenario(scenarioPath As String)
    Dim processName As String = "wa7"

    If Not File.Exists(scenarioPath) Then
        MessageBox.Show($"Scenario file not found: {scenarioPath}")
        Exit Sub
    End If

    ' Get or start WinActor
    Dim winActorProcess As Process() = Process.GetProcessesByName(processName)
    If winActorProcess.Length = 0 Then
        Process.Start("C:\Path\To\WinActor.exe")
        Threading.Thread.Sleep(5000)
        winActorProcess = Process.GetProcessesByName(processName)
    End If

    If winActorProcess.Length = 0 Then
        MessageBox.Show("WinActor not running.")
        Exit Sub
    End If

    ' Focus WinActor
    SetForegroundWindow(winActorProcess(0).MainWindowHandle)
    Threading.Thread.Sleep(500)

    ' If any scenario is open, close it
    If winActorProcess(0).MainWindowTitle.Contains(".ums") OrElse winActorProcess(0).MainWindowTitle.Contains(".ums7") Then
        CloseCurrentScenario(winActorProcess(0).MainWindowHandle)
    End If

    ' Try Ctrl+O
    Dim oldTitle = winActorProcess(0).MainWindowTitle
    SendKeys.SendWait("^{o}")
    Threading.Thread.Sleep(1000)

    ' If Ctrl+O didn‚Äôt work, use File‚ÜíOpen
    If winActorProcess(0).MainWindowTitle = oldTitle Then
        ClickMenuItem(winActorProcess(0).MainWindowHandle, "File", "Open")
    End If

    ' Type scenario path
    SendKeys.SendWait(scenarioPath)
    Threading.Thread.Sleep(500)
    SendKeys.SendWait("{ENTER}")
    Threading.Thread.Sleep(2000)

    ' Start execution (F5 key in WinActor)
    SendKeys.SendWait("{F5}")
    Threading.Thread.Sleep(1000)

    ' Wait for execution to finish
    WaitForExecutionFinish(winActorProcess(0))

    ' Show confirmation
    MessageBox.Show($"{Path.GetFileName(scenarioPath)} execution finished.")
End Sub

Private Sub WaitForExecutionFinish(proc As Process)
    Dim prevTitle As String = ""
    Dim stillRunning As Boolean = True

    While stillRunning
        Threading.Thread.Sleep(1000) ' check every second
        Try
            Dim currentTitle = proc.MainWindowTitle
            ' Running scenarios in WinActor 7 usually show [Running] in the title
            If Not currentTitle.Contains("[Running]") Then
                stillRunning = False
            End If
        Catch
            stillRunning = False
        End Try
    End While
End Sub


---

How it works:

1. After opening the scenario, the code sends F5 to start execution.


2. While execution is running, the window title contains [Running].


3. It keeps checking the title every second until [Running] disappears.


4. When finished ‚Üí shows a MessageBox confirming completion.




---

Question for you:
Does your WinActor always show [Running] in the title bar during execution?
If not, I can instead detect execution by checking if the Start button is disabled and re-enabled via UI Automation. That would work even if the title doesn‚Äôt change.







